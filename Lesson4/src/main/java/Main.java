import java.util.Random;
import java.util.Scanner;

public class Main {

    public static final int SIZE = 5; /*Количество клеток */
    public static final int QUANTITY_TO_WIN = 4; /* Количество клеток для победы */
    public static final char SIMBOL_USER = 'X'; /* Значок пользователя */
    public static final char SIMBOL_COMP = 'O'; /* Значок компьютера */
    public static final char EMPTY = '-'; /* Значок пустого поля */

    public static Scanner scanner = new Scanner(System.in);
    public static Random random = new Random();

    public static void main(String[] args) {

        /*Создаем двумерный пустой массив, который будет нашим полем */
        char[][] pole = new char[SIZE][SIZE];
        /*Заполняем его символами */
        for (int i = 0; i < pole.length; i++){
            for (int j = 0; j < pole[i].length; j++){
                pole[i][j] = EMPTY;
            }
        }
        print(pole);
        boolean Win = false;
        while (!Win){   /* Цикл в котором происходит вся игра, он выходит из него когда ктото выигрывает, и переменная Win=true */
            while (true){ /* ХОД ПОЛЬЗОВАТЕЛЯ */
                /* Пишем ход пользователя в цикле, что бы можно было спрашивать ввод цифр пока он не введет цифры пустой позиции*/
                System.out.print("Введите ячейку куда сходить: ");
                String getMove = scanner.nextLine(); /*Получаем строку от пользователя, в формате: 1 2. */
                String[] MoveString = getMove.split(" "); /*разбиваем строку на массив строк, по пробелу */
                int[] move = new int[MoveString.length]; /*Создаем числовой массив такой же длинны как и строковый(который получили от пользователя) */
                for (int i = 0; i < MoveString.length; i++){
                    move[i] = Integer.parseInt(MoveString[i]); /*В цикле проходимся по каждому элементу массива строк и преобразуем строки в числа, с добавлением в числовой массив */
                }
                if ((move[0]-1) >= SIZE || (move[1]-1) >= SIZE){ /*Проверяем входит ли введенное пользователем число в поле */
                    System.out.println("Вы ввели число выходящее за поле игры, введите заново!");
                    continue;
                }
                if ( pole[move[0]-1][move[1]-1] != EMPTY){ /*Проверяем пустое ли введенное пользователем число в поле */
                    System.out.println("В это поле уже ходили, переходите заново!");
                    continue;
                }
                pole[move[0]-1][move[1]-1] = SIMBOL_USER; /* Ставим в элемент который введ пользователь -1(что бы пользователю было удобно) крестик проверяя не ходил ли туда уже прежде */
                print(pole);
                break;

            }
            Win = isWin(pole, SIMBOL_USER, QUANTITY_TO_WIN); /*После каждой итерации цикла для пользователя проверяется, выйграл ли он */
            if (Win == true){
                System.out.println("Победил Пользователь");
                break;
            }
            System.out.println("Следующий ход!");

            while (true){ /*ХОД КОМПЬЮТЕРА */
                int moveX = random.nextInt(SIZE); /* Генерируем случайные числа для хода компьютера */
                int moveY = random.nextInt(SIZE);
                if (pole[moveX][moveY] == EMPTY ){ /* Проверяем пустая ли ячейка и записываем в нее значение */
                    pole[moveX][moveY] = SIMBOL_COMP;
                    print(pole);
                    break;
                }
            }
            Win = isWin(pole, SIMBOL_COMP, QUANTITY_TO_WIN); /*После каждой итерации цикла для компьютера проверяется, выйграл ли он */
            if (Win == true){
                System.out.println("Победил Компьютер");
                break;
            }
            System.out.println("Следующий ход!");
        }
    }

    /*МЕТОД ОПРЕДЕЛЯЮЩИЙ ПОБЕДИТЕЛЯ */
    /*не зависит от количества ячеек и необходимой длинны совпадений */
    public static boolean isWin(char[][] araay, char simbol, int qWin){
        int count = 0; /* Создаем переменную счетчик */
        /* ПРОВЕРЯЕМ ПО ГОРИЗОНТАЛИ */
        for (int i = 0; i < araay.length; i++){ /* Создаем цикл что бы пройтись по массиву */
            for (int j = 1; j < araay[i].length; j++){
                if ( araay[i][j] == simbol && araay[i][j-1] == simbol){ /* Если второй элемент подмассива равен предыдущему, значит в нем тоже стоит символ, значит увеличиваем счетчик */
                    count++;
                }
            }if (count == (qWin-1)){ /* В каждой строке основного массива проверяем, что если счетчик меньше на единицу того числа что требуется для победы, то возвращаем true- победу (тут выполняется то что проверяется сразу два элемента начиная со второго, поэтому количество совпавших должно быть меньше на 1 чем требуемое число */
                return true;
            }else { /* если в строке нет подряд нужного кол-ва элементов, то обнуляем счетчик и считаем для следующей строки */
                count = 0;
            }
        }
        count = 0;
        /* ПРОВЕРЯЕМ ПО ВЕРТИКАЛИ */
        for (int i = 0; i < araay.length; i++){ /* Создаем цикл что бы пройтись по массиву */
            for (int j = 0; j < araay.length && (j+1) < araay.length; j++){
                if(araay[j][i] == simbol && araay[j+1][i] ==simbol){
                    count++;
                }
            }if (count == (qWin-1)){ /* В каждой строке основного массива проверяем, что если счетчик меньше на единицу того числа что требуется для победы, то возвращаем true- победу (тут выполняется то что проверяется сразу два элемента начиная со второго, поэтому количество совпавших должно быть меньше на 1 чем требуемое число */
                return true;
            }else { /* если в строке нет подряд нужного кол-ва элементов, то обнуляем счетчик и считаем для следующей строки */
                count = 0;
            }
        }
        count = 0; /* Если построчно не выйграли переходим к проверке по диагонали, обнуляя счетчик */
        /* ПРОВЕРЯЕМ ПО ДИАГОНАЛИ В ПЛЮС */
        for (int i = 0; i < araay.length; i++){   /* Цикл для прохода по вертикали */
            for (int j = 0; j <araay[i].length; j++){  /* Цикл для прохода по горизонтали */
                if ( araay[i][j] == simbol){  /* Если он находит нужный символ, то он начинает в новом цикле прибовлять к значению позиции по +1 и если опять попадает в нужный символ то прибавляет count+1 */
                    for (int k = 0, m = i; (k+j) < araay.length-1 && m < araay.length; k++, m++){ /*Начинает от позиции совпадения первого символа, прибавляя +1 до размера поля  */
                        if( araay[(i+k)][(j+k)] == simbol){
                            count++;
                        }
                    }
                }
            }if (count == qWin){  /* После каждой строки проверяет равно ли совпадений по диагонали нужному количеству, если равно то выводит победителя возвращая true */
                return true;
            }else {
                count = 0; /* Если не находит, то снова обнуляет счетчик для строки */
            }
        }
        /* ПРОВЕРЯЕМ ПО ДИАГОНАЛИ В МИНУС */
        for (int i = 0; i < araay.length; i++){   /* Цикл для прохода по вертикали */
            for (int j = 0; j <araay[i].length; j++){  /* Цикл для прохода по горизонтали */
                if ( araay[i][j] == simbol){  /* Если он находит нужный символ, то он начинает проверять вверх и вправо */
                    for (int k = 0, m = i; (j+k) < araay.length && m >= 0; k++, m--){ /*начинает с текущей позиции поднимаясь на строчку вверх -1, и уыеличивая строку на +1  */
                        if( araay[(i-k)][(j+k)] == simbol){
                            count++;
                        }
                    }
                }
            }if (count == qWin){  /* После каждой строки проверяет равно ли совпадений по диагонали нужному количеству, если равно то выводит победителя возвращая true */
                return true;
            }else {
                count = 0; /* Если не находит, то снова обнуляет счетчик для строки */
            }
        }
        return false;
    }


    /*МЕТОД ВЫВОДЯЩИЙ ПОЛЕ НА ЭКРАН */
    public static void print(char[][] array){
        for (int i = 0; i < array.length; i++){
            for (int j = 0; j < array[i].length; j++){
                System.out.print(array[i][j] + " ");
            }
            System.out.println("");
        }
    }
}
